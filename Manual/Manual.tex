\documentclass{article}
\usepackage[affil-it]{authblk}
\usepackage{listings}
% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}
\usepackage{enumitem}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
%\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

%\title{\includegraphics[width=0.3\textwidth]{rino2.jpg}  \hspace*{2cm} \Huge{RINO User Manual}  }
\title{\includegraphics[scale=0.4]{rino2.jpg} \\  \Huge{RINO User Manual}  }
\author{Eric Goubault and Sylvie Putot}
\affil{LIX, Ecole Polytechnique, CNRS and Institut Polytechnique de Paris,  \\91128
Palaiseau, France \\ name.surname@polytechnique.edu}


\begin{document}



\maketitle



\begin{abstract}
We present the C++ RINO library, available on \url{https://github.com/cosynus-lix/RINO/},  for the computation of inner and outer approximations of reachable sets for uncertain discrete-time or continous-time dynamical systems, with (possibly time-varying) disturbances and control inputs, where some of the control inputs can be specified as outputs of a neural network.

For continuous-time systems, it relies on Taylor expansions in time and affine arithmetic (i.e. zonotopes) in space based reachability analysis to compute outer envelopes of all possible trajectories of an uncertain system. Additionally, it uses a generalized mean-value theorem to deduce inner tubes, that contain only states guaranteed to be reached. It also studies robust versions of these tubes, when there can be control inputs and perturbations to the system. Finally, the control can be specified as the output of a neural network which inputs are the system state.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction and references}
 RINO implements the following:
\begin{itemize}[noitemsep]
\item Forward inner and outer-approximated reachability of non-linear differential systems~\cite{hscc2017}.  The reachability algorithm relies on Taylor expansions in time and affine arithmetic (i.e. zonotopes) in space for computing over or outer-approximating tubes.  Under or inner-approximating tubes are deduced by application of a generalized mean-value theorem to the flow of the system.  This supposes to compute an over-approximation of the solution flow and its Jacobian with respect to uncertain inputs and initial conditions.
\item Forward inner and outer-approximated reachability of non-linear delay differential systems with constant delay~\cite{cav18}.  Using the classical method of steps,  the problem is reduced to the reachability analysis of a sequence of non-linear differential systems. 
\item Robust inner and outer approximations of differential systems with possibly time-varying disturbances~\cite{hscc19}: the above reachability analysis is extended to the case with both disturbances and control inputs.
\item In \cite{hscc2017,cav18,hscc19},  inner-approximations are computed for one-dimensional projections.  RINO also implements vector-valued inner-approximations~\cite{lcss2020}. (in practice, 2 and 3-dimensional projections).
\item In \cite{hscc2017,cav18,hscc19,lcss2020}, the under-approximation relies on a mean-value theorem, which may be imprecise in some cases.  In~\cite{adhs21}, higher-order inner-approximations are proposed.  They are implemented in RINO in the case of discrete-time dynamical systems.   
\item In \cite{hscc2017,cav18,hscc19,lcss2020,adhs21}, the control inputs are specified either in a range (for constant or piecewise constant inputs) or as solution of a differential system (for differentiable time-varying inputs).  Some of the control inputs can also be specified as the output of a neural network taking as input the system state~\cite{cav22}. This constitutes neural network controlled systems.  In RINO, the underlying dynamical system can be either discrete-time or continuous time.  For the time being, the activation functions have to be differentiable functions (typically sigmoid and hyperbolic tangent). 



\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation}

\subsection{Using docker}

Get the RINO directory and run 
\begin{verbatim}
$ docker build .
\end{verbatim}
An image \texttt{shaxyz...}  is built which you can run by 
\begin{verbatim}
$ docker run -it --name rino shaxyz.... 
\end{verbatim}
You can then execute RINO from directory /home/RINO as described in Section \ref{running}.

\subsection{Building from sources}

%\setlist{nolistsep}

\begin{itemize}[noitemsep]

\item You need g++, LAPACK and BLAS installed. Python visualization was tested with Python 3.8.8. 

\item Install the FILIB++ Interval Library, available from \url{http://www2.math.uni-wuppertal.de/wrswt/software/filib.html} (we used Version 3.0.2), and set variable \$FILIBHOME

\item Get and unzip the FADBAD++ automatic diffentiation package, available from \url{http://www.fadbad.com/fadbad.html} (we used FADBAD++ 2.1), and set variable \$FADBADHOME.
Copy files fadbad.h and fadiff.h from RINO/FADBAD\_Modified/ into your FADBAD++ distribution (we modified these files to add differentiation of activation functions).

\item A slightly modified of the third party package for Affine Arithmetic aaflib-0.1 (\url{http://aaflib.sourceforge.net}) has been included in the current directory. 
Future plans include separating more cleanly the initial version and our modifications...
Go to directory aaflib-0.1 within the current package and compile by "make static". 

\item Returning to the main (RINO) directory, you can now compile by "make" and obtain the "main" executable. 
\end{itemize}
The installation has been mostly tested on MacOS, but should also work on Ubuntu. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Running the reachability analysis \label{running}}

For now, the dynamics of systems on which to perform reachability analysis are defined as C++ code and given a fixed id used to run their analysis:
\begin{itemize}[noitemsep]
\item  for ODEs and DDEs in ```ode\_def.h``` (system and constant parameters) and ```ode\_def.cpp``` (parameters, initial conditions and input ranges)
\item for discrete-time systems in ```discrete\_system.h``` and ```discrete\_system.cpp``` 
  \end{itemize}
Running an example is then performed at command line, in directory /home/RINO, by 
\begin{verbatim}
$ ./rino [-systype system_type -syschoice system_id] [-nnfile-sfx nnfile.sfx] 
[-configfile cfgfile.txt]
\end{verbatim}
where 
\begin{itemize}[noitemsep]
\item \texttt{system\_type} is either \texttt{ode} (for a system of Ordinary Differential Equations) or \texttt{dde} (for a system of Delay Differential Equations) or \texttt{discrete} (for a discrete-time dynamical system)
\item \texttt{system\_id} is an integer specifying the predefined system identifier (matching variable syschoice in file ode\_def.h for ODEs and DDEs and  discrete\_system.h for discrete-time systems )
\item \texttt{nnfile.sfx}  contains a neural network in the Sherlock \texttt{sfx} format (\url{https://github.com/souradeep-111/sherlock/blob/master/sherlock-network-format.pdf}) 
\item \texttt{cfgfile.txt} specifies analysis parameters,  inputs,  initial conditions of the system.  
\end{itemize}

Note that default values for parameters, inputs and initial conditions of the system are set in the code.  If a configuration file is used,  the configuration file values override those present in the code. 

At command line,  either the system type and choice should be specified, or a configuration file containing this information should be provided.  If both are provided,  the configuration file information overrides command-line options.  Finally,  the  name of file containing the neural network, when relevant,  can be provided either at command-line or in the configuration file. 

The parameters which can be set in the configuration file are described in Section \ref{params}.  The commands for running the different examples presented in our work are given in Section \ref{existing}.

%The examples of neural network files are in directory ```Examples/Networks```.

\subsection{Running existing systems \label{existing}}

\subsubsection{Continuous-time differential systems (ODEs)}

\begin{itemize}[noitemsep]
\item The Brusselator example~\cite{hscc2017} (the system is an ODE and is given syschoice identifiant equal to 2) is run by:
\begin{verbatim}
$./rino -systype ode -syschoice 2
\end{verbatim}
or if you want to use a configuration file to modify the parameter and initial conditions, by:
  \begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_ode_2.txt
\end{verbatim}
In what follows,  we will use the following aggregate notation to indicate these two alternatives:
  \begin{verbatim}
$./rino -systype ode -syschoice 2 [-configfile Examples/ConfigFiles/cfg_ode_2.txt]
\end{verbatim}
\item The self-driving car example \cite{hscc19}  is run by 
 \begin{verbatim}
$./rino -systype ode -syschoice 6 [-configfile Examples/ConfigFiles/cfg_ode_6.txt]
\end{verbatim}
% or  \begin{verbatim}
%$ ./rino -configfile Examples/ConfigFiles/cfg_ode_6.txt
% \end{verbatim}
% \item the crazyflie model of Reference [HSCC 2019]  is run by "./rino -systype ode -syschoice 18 [Examples/ConfigFiles/cfg_ode_18.txt]" )
  \end{itemize}
  
\subsubsection{Continuous-time delay differential systems with constant delays (DDEs)}
\begin{itemize}[noitemsep]
\item  The running example of \cite{cav18} is run  by 
\begin{verbatim}
$./rino -systype dde -syschoice 1 [-configfile Examples/ConfigFiles/cfg_dde_1.txt]
\end{verbatim}
\item  Example 10 of \cite{cav18} is run  by 
\begin{verbatim}
$./rino -systype dde -syschoice 3 [-configfile Examples/ConfigFiles/cfg_dde_3.txt]
\end{verbatim}
\item  Example 9 (self-driving car with uncertain PID coefficients) of \cite{cav18} is run  by 
\begin{verbatim}
$./rino -systype dde -syschoice 8 [-configfile Examples/ConfigFiles/cfg_dde_8.txt]
\end{verbatim}
\item  The platoon examples of \cite{cav18} are run, for 5 vehicles by 
\begin{verbatim}
$./rino -systype dde -syschoice 10 [-configfile Examples/ConfigFiles/cfg_dde_10.txt]
\end{verbatim}
or for 10 vehicles by: 
\begin{verbatim}
$./rino -systype dde -syschoice 11 [-configfile Examples/ConfigFiles/cfg_dde_11.txt]
\end{verbatim}
 \end{itemize}

\subsubsection{Discrete-time dynamical systems}
\begin{itemize}[noitemsep]
\item the test model of \cite{adhs21} with Algorithm 1 is run by 
\begin{verbatim}
$./rino -systype discrete -syschoice 15 -nbsteps 25 [-iter_method 1] 
[-AEextension_order 1] [-skew 1]
\end{verbatim} 
or equivalently
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_discrete_15.txt
\end{verbatim}
\item the SIR epidemic model of \cite{adhs21} with Algorithm 1 (Fig. 3) is run by 
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_discrete_16_1.txt
\end{verbatim} 
and the same model with different initial conditions and Algorithm 2 (Fig. 4) is run by  
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_discrete_16_2.txt
\end{verbatim}
\item the Honeybees Site Choice Model \cite{adhs21} with Algorithm 2 is run by 
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_discrete_17.txt
\end{verbatim}
 \end{itemize}
 
\subsubsection{Neural network controlled dynamical systems (continuous or discrete time)}
The  examples of ~\cite{cav22} can be run by
\begin{itemize}[noitemsep]
\item TORA:
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_tora_tanh.txt
$./rino -configfile Examples/ConfigFiles/cfg_tora_sigmoid.txt
\end{verbatim}
\item B1:
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_B1_tanh.txt
$./rino -configfile Examples/ConfigFiles/cfg_B1_sigmoid.txt
\end{verbatim}
\item B2
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_B2_sigmoid.txt
\end{verbatim}
\item B3
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_B3_tanh.txt
$./rino -configfile Examples/ConfigFiles/cfg_B3_sigmoid.txt
\end{verbatim}
\item B4:
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_B4_tanh.txt
$./rino -configfile Examples/ConfigFiles/cfg_B4_sigmoid.txt
\end{verbatim}
\item B5:
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_B5_tanh.txt
$./rino -configfile Examples/ConfigFiles/cfg_B5_sigmoid.txt
\end{verbatim}
\item ACC:
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_acc_tanh.txt
\end{verbatim}
\item Continuous-time Mountain Car
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_MC_sigmoid.txt
\end{verbatim}
\item Discrete-time Mountain Car
\begin{verbatim}
$./rino -configfile Examples/ConfigFiles/cfg_discrete_mc.txt
\end{verbatim}
\end{itemize}
\subsection{Adding one's own example}
In short (to be completed, but a lot of additional information can already be found in Section~\ref{params} and \ref{examples}):
\begin{itemize}[noitemsep]
\item For ODEs,  the dynamical system should be given an (unused) syschoice ID and the dynamics defined in file \texttt{ode\_def.h}, in class OdeFunc,  by the vector yp  of time derivatives as function of state vector y and possibly parameters.  

The dimension of the state vector (sysdim) needs to be set in file \texttt{ode\_def.cpp} in function define\_system\_dim(). The parameters and initial values (if not given at command line in a configuration file) need to be set in function init\_system() in the same file. 

\item For discrete-time systems, the process is very similar but in a different location. Give the system  an (unused) syschoice ID and define the dynamics in file \texttt{discrete\_system.h}, in class DiscreteFunc, by the vector z of next discrete state as a function of the current state x and possibly parameters. 
The dimension of the state vector (sysdim) and the initial conditions need to be set in file \texttt{discrete\_system.h}  in function init\_discrete\_system().  
\end{itemize}
Both continuous-time and discrete-time systems can take (see also Sections \ref{params} and \ref{examples})
\begin{itemize}[noitemsep]
\item constant but possibly uncertain parameters (vector variable \texttt{params} in the C++ code),
\item constant or piecewise constant control inputs or disturbances (vector variable \texttt{param\_inputs} in the C++ code),
\item control inputs defined as the output of a neural network which input is the system state  (vector variable \texttt{control\_inputs} in the C++ code).
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Parameters of analysis and Configuration File \label{params}}
We list in this section the parameters and inputs of the system that can be set in the configuration file.  All of these parameters have default values in the program, so that they may be ommitted in the configuration file. 
For examples of use, we refer the reader to:
\begin{itemize}[noitemsep]
\item Section~\ref{existing} for sample files (in directory Examples/ConfigFiles) for existing examples,
\item Section~\ref{examples} for fully detailed results on chosen examples.
\end{itemize}
\subsection{Parameters of the analysis common to all system types}

\paragraph{System definition}
\begin{itemize}
\item Keyword \texttt{systype}: class of dynamical system, can be equal to \texttt{ode, dde, discrete}.  For example:
\begin{verbatim}
systype = ode
\end{verbatim}

\item Keyword \texttt{syschoice}: identifier for dynamical system,  should be equal to an integer, and matched by a system definition in RINO.
\begin{itemize}
\item if systype is \texttt{ode}, the dynamics of the system should be defined in   \texttt{ode\_def.h}, in class OdeFunc,  by the vector yp  of time derivatives as function of state vector y and possibly system parameters, 
\item if systype is \texttt{dde}, the dynamics of the system should be defined in   \texttt{ode\_def.h}, in class DdeFunc,  by the vector yp  of time derivatives as function of state vector y and delayed state vector y\_prev,  and possibly parameters,
\item if systype is \texttt{discrete},  the dynamics should be defined in \texttt{discrete\_system.h}, in class DiscreteFunc, by the vector z of next discrete state as a function of the current state x and possibly system parameters. 
\end{itemize}
Note that the same syschoice identifier can be used (with different system definition) for different values of systype.  
For example:
\begin{verbatim}
syschoice = 2
\end{verbatim}
\end{itemize}

\paragraph{Uncertain inputs and initial conditions}
\begin{itemize}
\item Keyword \texttt{initial-values}: should be equal to a sequence of intervals separated by a white space, which length is the dimension of the system (equal to global variable \texttt{sysdim} in the code).  The cartesian product of these intervals defines the set of initial values of the dynamical system, whatever its type. 
For example:
\begin{verbatim}
initial-values = [-0.1,0.1] [0,0.1] [1.9,2.1] [2.9,3.1]
\end{verbatim}
In cases when the accuracy of analysis is not considered sufficient, it can be refined by partitioning one component of the initial domain (for the time being, only one component at at time can be partitioned).  
You can specify the component you want to subdivide and the number of partitions. For example,  for 2 subdivisions for the last component: 
\begin{verbatim}
initial-values = [-0.1,0.1] [0,0.1] [1.9,2.1] ([2.9,3.1],2) 
\end{verbatim}
[***Warning***: the partitioning functionality is implemented only for systype ode and dde and has not been tested recently] 

\item Keyword \texttt{inputs}: for constant but uncertain inputs,  should be equal to a sequence of  intervals separated by a white space,  which length is the dimension of the input vector (equal to global variable \texttt{inputsdim} in the code). In class OdeFunc, the variable name for these inputs is \texttt{param\_inputs}.
For example:
\begin{verbatim}
inputs = [-0.1,0.1] [-0.1,0.1]
\end{verbatim}
For piecewise constant inputs,  one can specify the number of pieces for the piecewise constant function over the time horizon.  A constant input period is supposed.
For example, for an input which first component is constant and second component is piecewise constant with 10 pieces:
\begin{verbatim}
inputs = ([-0.1,0.1],1) ([-0.1,0.1],10) # same as inputs = [-0.1,0.1] ([-0.1,0.1],10)
\end{verbatim}

\item Keyword \texttt{uncontrolled}: should be equal to a sequence of integers which length is smaller or equal to the dimension of the input vector. It defines which dimensions of the inputs (numbered starting from 1) are disturbances, the remaining dimensions being considered as control inputs.
For example,  if the first 2 dimensions of the input vectors are disturbances:
\begin{verbatim}
uncontrolled = 1 2
\end{verbatim}


\item Keyword \texttt{params}: should be equal to  a sequence of  intervals separated by a white space,  which length is the dimension of the vector of uncertain but constant parameters (equal to global variable  \texttt{paramsdim} in the code).  In class OdeFunc, the variable name for these parameters is \texttt{params}.
For example:
\begin{verbatim}
params = [2,2] [3,4]
\end{verbatim}
Parameters are handled differently from inputs in the definition of the robust reachable sets~\cite{hscc19}.  In particular,  they don't add dimensions to the Jacobian matrix of the trajectories, used to compute the robust under and over-appproximations. 
\end{itemize}

\paragraph{Output results and visualization}
\begin{itemize}
\item Keyword \texttt{samples-per-dim}: should be an integer defining the number of samples in each input dimension used  for reachable set estimation by trajectory samples.  The samples are used  to compute estimated ranges for each state variable and to print sample points at different integration time steps of the analysis.
For example:
\begin{verbatim}
samples-per-dim = 20
\end{verbatim}

\item Keyword \texttt{create-png}: should be 0 or 1. If 0, the visualization script is not called by the analysis (in which case only the data file are produced,  the visualization script can be run a posteriori, see Section \ref{visu}).
For example, for not calling the visualization script:
\begin{verbatim}
create-png = 0
\end{verbatim}

\item Keyword \texttt{interactive-visualization}: should be 0 or 1.  If 0,  the figures are only saved in the output directory (provided create-png is 1), otherwise they are also plotted on screen. 
For example:
\begin{verbatim}
interactive-visualization = 1
\end{verbatim}

\item Keyword \texttt{points-per-graph}: should be an integer specifying the number of time points saved in the output files and printed on graphs. This is disconnected from the analysis time steps, and only means that the state may not be saved for all time steps, for better lisibility. 
For example:
\begin{verbatim}
points-per-graph = 50
\end{verbatim}

\item Keyword \texttt{variables-to-display}: should be a sequence of integer greater or equal to 1 indicating the dimensions we wish to visualize graphically (the data output files will still be produced for all dimensions). This is useful for examples of large dimensions when all dimensions may not be meaningful. 
For example:
\begin{verbatim}
variables-to-display = 1 2
\end{verbatim}
If we want to display figures for all dimensions (which is the default when the option is not set in the config file):
\begin{verbatim}
variables-to-display = all
\end{verbatim}
\end{itemize}

\subsection{Parameters specific to ODEs (systype is ode)}

\begin{verbatim}
time-horizon = 5.

# time step
integration-step = 0.02

# order for Taylor models in time
order = 3

# refined mean-value theorem for inner-approximation (default is 0: classical mean value)
refined-mean-value = 1
\end{verbatim}

\subsection{Parameters specific to DDEs (systype is dde)}

\begin{verbatim}
time-horizon = 5.

# only for DDEs (for ODEs, starting-time is set to 0)
starting-time = -0.3

# only for DDEs
delay = 0.3 

# defines the time-step by delay/nb-time-subdivisions
nb-time-subdivisions = 3

# order for Taylor models in time
order = 3

# refined mean-value theorem for inner-approximation (default is 0: classical mean value)
refined-mean-value = 1
\end{verbatim}

\subsection{Parameters specific to discrete-time systems (systype is discrete)}

\begin{verbatim}
# number of discrete time steps
nbsteps = 25

# iterating algorithm (Algorithm 1 or 2 in [ADHS2021])
iter-method = 1

# computing skewed box joint approximation or regular boxes (influences the precision for Algorithm 1, mostly for visualization for Algorithm 2)
skew = 1

# Order of the AE extension (1 for mean-value, 2 for Taylor-based higher-order extension)
AEextension-order = 1
\end{verbatim}

\subsection{Parameters specific to neural network controlled dynamical systems (systype can be either ode or discrete)}

\begin{verbatim}
# file containing the neural network in Sherlock sfx format (https://github.com/souradeep-111/sherlock/blob/master/sherlock-network-format.pdf) 
nnfile-sfx = Examples/Networks/tora_tanh.sfx

# when relevant, final offset and scaling of the output of the network:
nn-offset = 0. # also read from nn file (erasing this one)
nn-scaling = 11.  # also read from nn file (erasing this one)

# control time step
control-step = 0.1
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Visualizing results \label{visu}}

\paragraph{Analysis output files}
After running an example, all results are in the subdirectory ‘output’. They are provided in the following files : 
\begin{itemize}[noitemsep]
\item \texttt{sumup.txt}: summary of configuration, running time and ranges at the final state of the analysis (part of this information can also be found with more significant digits in \texttt{sumup.yaml})
\item \texttt{samplesreachset.yaml}: sampled trajectories (used to assess accuracy of reachability results)
\item \texttt{approxreachset.yaml}: over and under-approximated reachset (projected, robust, joint ranges) and accuracy measures (eta, gamma) at each time step 
\end{itemize}

\paragraph{Running the visualization script}
A python visualization file \texttt{Visu\_output.py} is available in the GUI directory. It can be run from the analyzer (if variable create-png is set to 1 in the configuration file) but you can also run it separately,  provided the above data files are present in RINO/output.  It may even be required if you are running the docker version (see below the pararaph docker specifics).

For example, for an interactive analysis (prints the figures on screen, otherwise the files are simply saved in the output directory) and to produce figures only for variables x[1] and x[2]),  it is run by:
\begin{verbatim}
$cd GUI; python3 Visu_output.py --interactive=1 --printvar=-1-2; cd ..
\end{verbatim}
When the script is run by analyzer, the options set above in command line can be set in the configuration file by: 
\begin{verbatim}
interactive-visualization = 1
variables-to-display = 1 2
\end{verbatim}
\paragraph{One-dimensional projections}
%The files produced may slightly vary depending on the system type. (ode, dde, discrete-time).
For k ranging from 1 to system dimension, the following results files display the projected ranges on dimension k as function of time:
\begin{itemize}[noitemsep]
\item \texttt{xk\_max.png}  (e.g.  \texttt{x1\_max.png})  and \texttt{xk\_max\_sample.png}: the maximal inner and outer-approximations, with and without sampled trajectories
\item \texttt{xk.png},  \texttt{xk\_sample.png}: additionally to the maximal inner and outer-approximations, the robust approximations when relevant, with and without sampled trajectories
\end{itemize}
Global views are provided: \texttt{xi\_max.png} and \texttt{xi\_subplots\_min\_max.png} display the one-dimensional projected reachable sets for all variables on one graph. 

\paragraph{Two and three-dimensional projections}
For any couple (k,l) we also display 2-dimensional projections:
\begin{itemize}[noitemsep]
\item \texttt{xkxl.png}:  maximal (and when relevant robust~\cite{hscc19}) inner and outer-approximations of the joint or vector-valued range (xk,xl) as skewed boxes. (see e.g. ~\cite{lcss2020})
\item \texttt{xkxl\_sample.png}: sampled trajectories for (xk,xl) 
\item \texttt{xkxl\_approx\_sample.png}: on the same graph the inner and outer-approximations of the joint range (xk,xl) as skewed boxes and sampled trajectories
\item \texttt{xkxl\_box\_sample.png}: same as above but the approximations are printed as boxes (useful in a few cases where the skewed boxes have a bad behavior)
\item \texttt{xkxl\_finalstate.png}: box and skewed box inner and outer-approximations, robust when relevant, and sampled points at the final state of the analysis
\end{itemize}
Three-dimensional projections when relevant are also printed, only the corners of boxes are printed for more lisibility.

\paragraph{Error measures}
We display the following error measures (the closer to 1 the better) as functions of time (or iterations for discrete-time systems) in files \texttt{eta.png},  \texttt{gamma.png}: for the projection on each state variable, we define $\eta_o$ = (width of sampled set)/(width of outer-approx) ; $\eta_i$ = (width of inner-approx)/(width of sampled set);
$\gamma$ = (width of inner-approx)/(width of outer-approx).

\paragraph{Docker specifics}

It is rather difficult under docker to ensure that the visualization on the host
machine will go correctly without further machine-dependant local installations.
We can then turn off the automatic visualization in the configuration files 
and rely on a local execution of a python script file on the
host machine for generating the figures, as having a python installation working
on the host machine is much easier to ensure than the link between docker and
a X11 interface.

First, you have to make sure that you have an \texttt{output} directory under the \texttt{\$HOME/RINO} directory on the host machine (not under the docker container): 
\begin{verbatim}
> mkdir output
\end{verbatim}

Then for instance for retrieving on the host machine the elements after analysis needed for visualization on the host machine, you will need to type in a console on the host machine:

\begin{verbatim}
> cd $HOME/RINO/output
> docker cp rino:/home/RINO/output/approxreachset.yaml . 
> docker cp rino:/home/RINO/output/samplesreachset.yaml .
> docker cp rino:/home/RINO/output/sumup.txt .
> docker cp rino:/home/RINO/output/sumup.yaml .
\end{verbatim}


Then for visualization (make sure \texttt{python3} is installed on your host machine), you can e.g. write: %\todo{J'ai l'impression qu'il faut tous les fichiers dans output et pas que approx...yaml?}
\begin{verbatim}
> cd ../GUI ; python3 Visu_output.py --interactive=0 --printvar=-1-2 ; cd ../output ; ls
eta.png
gamma.png
x1.png
x1_max.png
x1_max_sample.png
x1_sample.png
xi_max.png
xi_subplots_max.png
(...)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples \label{examples}}

To be completed. 
%\section{Authors and References}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{License}

This project is licensed under the GNU LGPLv3 license - see the \url{https://github.com/cosynus-lix/RINO/blob/master/LICENSE} file for details.

%\begin{figure}
%\centering
%\includegraphics[width=0.3\textwidth]{frog.jpg}
%\caption{\label{fig:frog}This frog was uploaded via the file-tree menu.}
%\end{figure}


%\begin{table}
%\centering
%\begin{tabular}{l|r}
%Item & Quantity \\\hline
%Widgets & 42 \\
%Gadgets & 13
%\end{tabular}
%\caption{\label{tab:widgets}An example table.}
%\end{table}



\bibliographystyle{alpha}
\bibliography{rino}

\end{document}
